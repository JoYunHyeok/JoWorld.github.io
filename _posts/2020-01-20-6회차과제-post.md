---
title: "모각코 스터디 6회차 과제"
excerpt: "모각코 스터디 6회차 과제 문제풀이를 하였습니다."

categories:
  - Blog
tags:
  - Blog
last_modified_at: 2019-01-20
---
포도주 시식(2156번)  
풀이: 전에 풀었던 이친수 문제와 비슷하며 경우를 나누어 풀어야하는 문제입니다.  
D[i] = A[1] + ~ + A[i]까지 포도주를 마셨을 때, 마실 수 있는 포도주의 최대 양입니다.  
경우를 나눈다면,  
- 0번 연속해서 마신 포도주 -> A[i]를 마시지 않음 -> D[i-1]  
- 1번 연속해서 마신 포도주 -> A[i-1]를 마시지 않음 -> D[i-2] + A[i]  
- 2번 연속해서 마신 포도주 -> A[i-1]을 마시고, A[i-2]는 마시지 않음 -> D[i-3] + A[i-1] + A[i]  
종합해보면 D[i] = max(D[i-1], D[i-2] + A[i], D[i-3] + A[i-1] + A[i] )  
위에 식을 코드를 옮기면 아래와 같다.  
~~~java  
d[1] = a[1];  
		if (n >= 2) {  
			d[2] = a[1] + a[2];  
		}  
		for (int i = 3; i <= n; i++) {  
			d[i] = d[i - 1];  
			if (d[i] < d[i - 2] + a[i]) {  
				d[i] = d[i - 2] + a[i];  
			}  
			if (d[i] < d[i - 3] + a[i - 1] + a[i]) {  
				d[i] = d[i - 3] + a[i - 1] + a[i];  
			}  

		}  
~~~
포도주 시식문제는 점화식을 어떻게 세워야할지 초기값을 어떻게 설정해주어야할지 감이 잡히지 않아 답을 보며 이해하였습니다.  


정수삼각형(1932번)  
풀이: 어떤 수가 선택되기전에 선택될 수 있는 수는 대각선 왼쪽 위, 오른쪽 위가 되고 이 문제는 2차형배열을 써주어야 합니다.  
D[i][j] = i행 j열기 선택되었을 때 최대합  
(i,j)가 선택되기 전에 선택된 수는 (i-1,j),(i-1,j-1)중 하나 입니다.  
D[i][j] = MAX(D[i-1][j],D[i-1][j-1]) + A[i][j]의 점화식이 나오게 됩니다.  
위 점화식을 코드로 나타낸다면 아래와 같은 코드가 나오게 됩니다.  
~~~java  
for (int i = 1; i < n; i++) {
			for (int j = 0; j <= i; j++) {
				d[i][j] = d[i - 1][j] + a[i][j];
				if (j - 1 >= 0 && d[i][j] < d[i - 1][j - 1] + a[i][j]) {
					d[i][j] = d[i - 1][j - 1] + a[i][j];
				}
			}
		}
~~~  



가장 큰 증가하는 부분 수열(11055번)  
풀이: 이 문제는 전에 풀었던 가장 긴 증가하는 부분수열문제와 많이 흡사하기 때문에 어렵지 않게 풀었던 것 같다. 점화식을 세우면 D[i]=A[1],...,A[j],A[i]이며 A[j]를 구하려면 D[i]=MAX(D[j])+a[i]가 되며 코드로 나타내면 아래와 같은 코드가 나오게 됩니다.  
~~~java  
for(int i = 0; i < n; i++) {
			d[i] = a[i];
			for(int j = 0; j < i; j++) {
				if(a[j] < a[i] && d[i] < d[j] + a[i]) {
					d[i] = d[j] + a[i];
				}
			}
		}  
~~~  



가장 긴 감소하는 부분 수열(11722번)  
풀이: 이 문제도 지금까지 풀었던 수열 문제들의 코드에서 조금만 변형해주면 되는 문제이다. D[i] = A[i]에서 끝나는 가장 긴 감소하는 부분수열의 길이라고 하였을 때 A[i] 앞을 A[j]라고 하였을때 D[i] = MAX(D[j]+1)이 된다. 단, j < i , A[i] > A[j]의 조건을 만족시켜주면 된다. 위 점화식을 아래와 같은 코드로 나타낼 수 있다.  
~~~java  
for(int i = 0; i < n; i++ ) {
			d[i] = 1;
			for(int j = 0; j < i; j++) {
				if(a[j]>a[i] && d[i]<d[j]+1) {
					d[i]=d[j]+1;
				}
			}
		}  
~~~  

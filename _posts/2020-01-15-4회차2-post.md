---
title: "2020.01.14 스터디 4회차 마무리하며"
excerpt: "백준 복습 및 문제 풀이 + 회화"

categories:
  - (2019.12)동계 모각코
tags:
  - Blog
last_modified_at: 2019-01-14
---
모각코 세번째 스터디를 마무리하며 백준 과제 리뷰와 3문제를 풀었습니다.  

연속합(1912번)  
풀이 : 이 문제를 해결하려면 각각의 수에 대해 연속합을 구해야하며 앞에있는 수와 연속하는 경우와 연속하지 않는 경우로 나누어야 합니다.  

A배열은 입력되는 수열을 위해 생성합니다.  
D배열은 i번째 수로 끝나는 가장 큰 연속합을 위해 생성하는 배열 입니다.  
1.앞에 있는 수와 연속하는 경우 : D[i-1] + A[i]  
2.연속하지 않는 경우 : A[i]  
이 문제의 핵심부분을 코딩한다면 아래와 같은 코드가 나옵니다.  

~~~java
for(int i = 0; i < n; i++){
  d[i] = a[i]; //연속하지 않는 경우
  if(i == 0){
    continue;//0이면 바로 반복문으로
  }
  if(d[i] < d[i-1] + a[i]) // 앞에있는 수와 연속하는 경우
     d[i] = d[i-1] + a[i]
}
~~~  


제곱수의 합 (1699번)  
? + ? + ''' + ? + ? = N이 된다고 했을때 마지막 ? 값을 알면 되는 문제이며 이 자리에 올 수 있는 값은 제곱수들입니다. 제곱수들은 무수히 많기 때문에 i라는 변수를 두어 i^2으로 둡니다. i^2을 제외한 나머지는 N-i^2이 되고 정리한다면 (N-i^2) + i^2 = N이 됩니다.    
점화식으로 정의하면 D[N] = min(D[N-i^2]) + 1 이 됩니다.(1^2 <= i^2 <= N)  
위에서 세운 점화식을 코딩으로 옮겨 본다면 아래와 같은 코드가 나옵니다.  
~~~java  
for(int i = 0; i <= n; i++){
  d[i] = i; // 최솟값을 구하는 문제이므로 올수있는 최댓값으로 초기화 시켜줍니다.
  for(int j = 1; j*j <= i; j++){
    if(d[i] > d[i-j*j] + 1){
      d[i] = d[i-j*j] + 1;
    }
  }
}
~~~  


합분해 (2225번)  
먼저, 점화식을 세우면 D[K][N] = 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수  
? + ? + ''' + ? + ?(K개) = N 이 경우도 마찬가지로 마지막에 올 수있는 수에 변수를 둔다. L이라고 둔다면 (N-L) + L = N  (N-L)의 갯수는 K-1이 된다.  
즉, D[K][N] = D[k-1][N-L] (0<=L<=N) 식이 나오게 됩니다.  
점화식을 코딩으로 옮겨본다면 아래와 같습니다. 변수가 세개라서 for문을 세개를 써주었습니다.  
~~~java  
for(int i = 1; i <= k; i++){
  for(int j = 0; j <= n; j++){
    for(int l = 0; l <= j; l++){
      d[k][n] += d[k-1][j-l];
    }
  }
}
~~~  
